import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Random;
import java.util.Set;


public class GenerateBoards {

	public static void main(String[] args) {
		Set<Integer> closedSet = new HashSet<Integer>();

		int[] solved = {0,1,2,3,4,5,6,7,8};
		AStar a = new AStar(solved);


		List<AStar> l = new ArrayList<AStar>();
		//int[] order = {1,2,0,3,4,7,6,8,5};
		//AStar a = new AStar(order);
//		while(!a.isSolvable()){
//			a = new AStar();
//		}
		System.out.println(a);

		l.add(a);
		int size = l.size();
		int nodesGenerated = 1;
		Random rand = new Random();
		int randomNum = rand.nextInt((size - 0) + 1);
	    // nextInt is normally exclusive of the top value,
	    // so add 1 to make it inclusive
	    
		
		while(l.peek().heuristic1()!=0){			
			AStar top = pq.poll();
			closedSet.add(top.getHash());
			List<AStar> possibleMoves = top.possMoves(top);
			for(int i = 0; i< possibleMoves.size(); i++){
				AStar currentNode = possibleMoves.get(i);

				if(!closedSet.contains(currentNode.getHash())){
					pq.add(possibleMoves.get(i));
					nodesGenerated++;
				}

			}
		}
		System.out.println(closedSet);
		//should be solution:
		System.out.println(pq.peek());
		//moves to get there:
		System.out.printf("Number of moves to solution: %d\n", pq.peek().getCost());
		//nodes"
		System.out.printf("Nodes generated: %d\n", nodesGenerated);


		//System.out.println(pq);

	}
}

//	int size=3;
//	
//	
//	public AStar generate(int size, AStar solved){
//		List<AStar> l = new ArrayList<AStar>();
//		int[] location = solved.blankLoc(solved);
//		int r = location[0];
//		int c = location[1];
//		int[] currentBoard = solved.orderBoard();
//		if (!isOutOfBounds(r - 1, c, solved)) {
//			AStar move1 = new AStar(currentBoard);
//			move1.cost = solved.cost + 1;
//			// System.out.println(move1.board[r-1][c]);
//			move1 = moveSquare(move1.board[r - 1][c], move1);
//			l.add(move1);
//		}
//		if (!isOutOfBounds(r, c + 1, solved)) {
//			AStar move2 = new AStar(currentBoard);
//			move2.cost = solved.cost + 1;
//			// System.out.println(move2.board[r][c+1]);
//			move2 = moveSquare(move2.board[r][c + 1], move2);
//			l.add(move2);
//		}
//		if (!isOutOfBounds(r + 1, c, solved)) {
//			AStar move3 = new AStar(currentBoard);
//			move3.cost = solved.cost + 1;
//			move3 = moveSquare(move3.board[r + 1][c], move3);
//			l.add(move3);
//		}
//		if (!isOutOfBounds(r, c - 1, solved)) {
//			AStar move4 = new AStar(currentBoard);
//			move4.cost = a.cost + 1;
//			move4 = moveSquare(move4.board[r][c - 1], move4);
//			l.add(move4);
//		}
//		return l;
//	}
//	
//	
//	
//	
//	
//		// takes the current board (a 2D array and returns a 1D array of the numbers
//		// written in order)
//		public int[] orderBoard(AStar a) {
//			int[] boardInOrder = new int[9];
//			int k = 0;
//			for (int i = 0; i < size; i++) {
//				for (int j = 0; j < size; j++) {
//					boardInOrder[k] = a.getBoard(i,j);
//					k++;
//				}
//			}
//			return boardInOrder;
//		}
}
